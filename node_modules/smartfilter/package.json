{
  "name": "smartfilter",
  "license": "Apache License 2.0",
  "main": "smartfilter.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/darshit-shah/Smartfilter.git"
  },
  "keywords": [
    "crossfilter",
    "server",
    "Smartfilter"
  ],
  "dependencies": {
    "node-database-connectors": "*"
  },
  "author": {
    "name": "Darshit Shah"
  },
  "bugs": {
    "url": "https://github.com/darshit-shah/Smartfilter/issues"
  },
  "homepage": "https://github.com/darshit-shah/Smartfilter",
  "directories": {
    "example": "example"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "description": "This is a node module bundled with Node Package Manager(NPM). It is a javascript and does not require any compilation.",
  "version": "0.0.16",
  "gitHead": "e177325cea0dfd9ea8d9d64f445c1f9d322a1ba3",
  "readme": "# SmartFilter\r\n\r\nSmartFilter is a node module bundled with Node Package Manager(NPM). It is a javascript and does not require any compilation.\r\n\r\n## What is SmartFilter?\r\n\r\nSmartFilter is inspired from a library called [Crossfilter](http://square.github.io/crossfilter/) which is fast browser side in-memory filtering mechanism across multiple dimensions and measures. One of the major limitations of using Crossfilter is to keep data in memory on client side in a browser. There are few modules available to create Crossfilter like functionality on server side. However, in big data world it is costly to transfer data from a source to either client or server side functions. `SmartFilter does not need raw data in memory either on client side or on server side.`  It creates data-provider specific query and fetch results directly from the source. Currently, it supports MySQL as a data source, however soon we will bring Elasticsearch, Hadoop and Big table connectors.\r\n\r\n## How SmartFilter works?\r\n\r\nSmartFilter creates `dynamic queries with filter conditions` based on previous filters applied on data source. Unlike usual ways of applying all filters, SmartFilter helps you fire a query only if it is required and reduces load on your database. Thus it automatically improves interactions with your Big data sources.\r\n\r\nSmartFilter comprises of another module called “node-database-connectors” for converting given JSON parameters to the relevant data-source specific query. Right now it supports MySQL, Elasticsearch and Google-big-query as data sources. So a common filter structure allows us to fire queries on data sources of your choice.\r\n\r\nLet me explain with an example, which will compare traditional approach and SmartFilter’s approach to perform same operations.\r\n\r\n###### Connect to your own data-provider\r\nFor this example, I am taking a reference of MySQL database, which has a table named “Stock” having 6500 rows and following columns\r\n1. Type: This is a string type of column having only two distinct values. \"Loss\" or \"Gain\"\r\n2. Qtr: This is also a string type of column having four values. \"Q1\", \"Q2\", \"Q3\" or \"Q4\"\r\n3. Volume: This is numeric type of column.\r\n\r\n###### Add pivot on \"Type\" field with \"Sum\" of \"Volume\" as measure\r\nBoth traditional and SmartFilter's approach will create a query something like *\"select Type, sum(Volume) from Stock group by Type\".*\r\n\r\nIn addition, `SmartFilter will store this query and corresponding result in cache` and next time when same query is generated, it will just return result from cache without querying the database.\r\n\r\n###### Apply Filter Qtr = 'Q1'\r\nHere also both will create a query like *\"select Type, sum(Volume) from Stock where Qtr in ['Q1'] group by Type\".*\r\n\r\nSame as step 2, SmartFilter will also store query and result in cache to use when needed.\r\n\r\n###### Apply Filter Qtr in ['Q1', 'Q2']\r\n\r\nIn Traditional Case it will fire new query like *\"select Type, sum(Volume) from Stock where Qtr in ['Q1', 'Q2'] group by Type\"*\r\n\r\nBut here, SmartFilter will `apply its own logic` to find its result. By comparing Step 3 and current filter conditions, it will identify that there is a `scope of improving filter condition`. Instead of fetching all records where *Qtr is either Q1 or Q2*, it should just fetch records where *Qtr is Q2* and `use existing cached result for Qtr = Q1 from above step`. So final query would be *\"select Type, sum(Volume) from Stock where Qtr in ['Q2'] group by Type\".* Once result is available, `it will merge it with result from above step` and final result is produced for given filter condition. And at the end it will store query and result in cache.\r\n\r\n###### Apply Filter Qtr = 'Q2'\r\n\r\nAgain here in traditional approach you will fire query like *\"select Type, sum(Volume) from Stock where Qtr in ['Q2'] group by Type\"*\r\n\r\nguess what, SmartFilter has already cached this query's and its output in Step 4. So `result is returned directly from cache without even touching database`.\r\n\r\n\r\n## API Reference\r\n\r\n```sh\r\n\r\n$ npm install smartfilter\r\n\r\n```\r\n\r\n## Introduction\r\n\r\nThis is a node.js module bundled with Node Package Manager(NPM). It is written in pure javascript and does not require any compilation.\r\n\r\nHere is an example how to include it:\r\n\r\n```js\r\n\r\nvar smartfilter = require('smartfilter');\r\nvar mysmartfilter = new smartfilter();\r\n\r\n```\r\n\r\nYou can create new object of SmartFilter number of times. Each object will store database configuration, dimensions, filters and previous results in memory seperatly.\r\n\r\n## How To?\r\n\r\nSmartFilter is build on message passing mechanism. This means whatever you want to do you only need to call single service 'smartfilterRequest'. This service will accept 'options' as first parameter and 'callback_method' as second parameter. It will identify what to do from 'options' which you have provided and once it is done, it will call 'callback_method' which will have output.\r\n\r\n```js\r\n\r\nmysmartfilter.smartfilterRequest(options, callback_method);\r\n\r\n```\r\n\r\nHere, 'options' is a JSON parameter which contains two keys\r\n1) type: here you need to tell what operations you want to perform. Right now you can specify one of ['connct', 'dimension', 'filter', 'data', 'count']\r\n2) data: here you need to specify supporting data for specified type. Details about supporting data is given further in this document.\r\n\r\n\r\n\r\n\r\n#### Connect To Database\r\n\r\nFirst of all you have to connect to a specific table of your database. For this, you need to pass database connection configurations and table name as supporting data.\r\n\r\nHere is a sample code to connect to 'Stock' table of given mysql database. \r\n\r\n```js\r\n\r\n//Database connection settings\r\nvar dbConfig = { \r\n  type: 'database',//type of connection. Currently connection to only database is available\r\n  databaseType: 'mysql', //type of database. Currently you can connect to only mysql database\r\n  host: '54.251.110.52', //host name of mysql database\r\n  port: '3306', //port on which mysql is listening\r\n  user: 'guest', //username to connect to database\r\n  password: 'guest', //password to access the database\r\n  database: 'DarshitShah' //Name of database\r\n};\r\n\r\n//call smartfilterRequest service with type = 'connect'.\r\nmysmartfilter.smartfilterRequest({ \r\n  type: 'connect', //name of operation you want to perform\r\n  data: { \r\n    tableName: 'Stock', //Name of the table on which you want to create smartfilter object\r\n    dbConfig: dbConfig //database configuration\r\n    } \r\n  }, function (output) {\r\n    if (output.type !== 'error') {\r\n      //In this case operation is completed successsfully.\r\n      console.log('Success', output);\r\n    }\r\n    else {\r\n      //In this case some error has occured.\r\n      console.log('Fail', output);\r\n    }\r\n  });\r\n\r\n```\r\n\r\n\r\n\r\n\r\n#### Add Pivot\r\n\r\nOnce you are successfully connected, you can add dimension to create new pivot definition. For this you need to provide Dimension Field, Measure Field and Aggregation Type on measure as supporting data.\r\n\r\nHere is a sample code to create a pivot on 'Type' as Dimension and 'Sum' of 'Volume' as Measure.\r\n\r\n```js\r\n\r\nmysmartfilter.smartfilterRequest({ \r\n  type: 'pivot', \r\n  data: { \r\n    reference: 'myPivot',\r\n    dimensions: [//Multiple dimensions can be specified\r\n      'Type'//Column name of Dimension field\r\n    ],\r\n    measures: [//Multiple measures can be specified\r\n      {\r\n        key: 'Volume', //Column name of Measure field\r\n        aggregation: 'sum'//type of aggregation which needs to be applied on measure\r\n      }\r\n    ]\r\n  } \r\n}, function (output) {\r\n  if (output.type !== 'error') {\r\n    //In this case operation is completed successsfully.\r\n    console.log('Success', output);\r\n  }\r\n  else {\r\n    //In this case some error has occured.\r\n    console.log('Fail', output);\r\n  }\r\n});\r\n\r\n```\r\n\r\n\r\n\r\n\r\n#### Apply Filter\r\n\r\nAfter you have created a pivot definition, you can specify your filter condition. To apply a filter you need to provide Column Name on which you want to apply a filter, type of filter (like 'in' or 'range') and array of values as supporting parameters.\r\n\r\nHere is a sample code to add filter on 'Qtr' column, with type of filter as 'in' and array of values as ['Q1', 'Q2']\r\n\r\n```js\r\n\r\nmysmartfilter.smartfilterRequest({ \r\n  type: 'filter', \r\n  data: { \r\n    field: 'Qtr', //Column name on which filter needs to be applied\r\n    filterType: 'in', //type of filter. 'in' means from list of values, 'range' means between\r\n    filters: ['Q1', 'Q2'] // Qtr should be either 'Q1' or 'Q2'\r\n    }    \r\n  }, function (output) {\r\n    if (output.type !== 'error') {\r\n      //In this case operation is completed successsfully.\r\n      console.log('Success', output);\r\n    }\r\n    else {\r\n      //In this case some error has occured.\r\n      console.log('Fail', output);\r\n    }\r\n  });\r\n\r\n```\r\n\r\n\r\n\r\n\r\n#### Fetch Raw Data\r\n\r\nNow if you want to fetch raw records from base table after applying all filter conditions, you can use below code.\r\n\r\n```js\r\n\r\nmysmartfilter.smartfilterRequest({ \r\n  type: 'data', // fetch raw data\r\n  data: {  }\r\n  }, function (output) {\r\n    if (output.type !== 'error') {\r\n      //In this case operation is completed successsfully.\r\n      console.log('Success', output);\r\n    }\r\n    else {\r\n      //In this case some error has occured.\r\n      console.log('Fail', output);\r\n    }\r\n  });\r\n\r\n```\r\n\r\n\r\n\r\n\r\n#### Fully working sample\r\n\r\nBelow sample would also show difference in approach between traditional way and SmartFilter's way to interact with database in inline comment.\r\n\r\n```js\r\nvar smartfilter = new require('smartfilter');\r\n\r\n//database connection setting.\r\nvar dbConfig = { type: \"database\", databaseType: 'mysql', database: 'DarshitShah', host: \"54.251.110.52\", port: \"3306\", user: \"guest\", password: \"guest\", multipleStatements: false };\r\n\r\n//create new instance of smartfilter\r\nvar mysmartfilter = new smartfilter();\r\n//Step 1. Connect to mysql database\r\nmysmartfilter.smartfilterRequest({ type: \"connect\", data: { tableName: \"Stock\", dbConfig: dbConfig} }, function (output) {\r\n    if (output.type !== 'error') {\r\n        /*\r\n        Step 2. Add pivot on 'Type' field with 'Sum' of 'Volume' as measure\r\n        Both traditional and SmartFilter's approach will create a query something like \"select Type, sum(Volume) from Stock group by Type\"\r\n        But SmartFilter will store this query and corresponding result in cache and next time when same query is generated, it will just return result from cache without querying any database.\r\n        */\r\n        mysmartfilter.smartfilterRequest({ type: \"pivot\", data: { reference:'myPivot', dimensions:['Type'], measures:[{ key: 'volume', aggregation: 'sum'}]} }, function (output) {\r\n            if (output.type !== 'error') {\r\n                /*\r\n                Step 3. Apply Filter Qtr = 'Q1'\r\n                Here also both will create a query like \"select Type, sum(Volume) from Stock where Qtr in ['Q1'] group by Type\"\r\n                And same as step 2, it will store query and result in cache\r\n                */\r\n                mysmartfilter.smartfilterRequest({ type: \"filter\", data: { field: 'Qtr', filters: ['Q1'], filterType: 'in'} }, function (output) {\r\n                    if (output.type !== 'error') {\r\n                        /*\r\n                        Step 4. Apply Filter Qtr in ['Q1', 'Q2']\r\n                        In Traditional Case it will fire new query like \"select Type, sum(Volume) from Stock where Qtr in ['Q1', 'Q2'] group by Type\"\r\n                        But here, SmartFilter will apply its own logic to find its result. \r\n                        By comparing Step 3 and current filter conditions, it will identify that there is a scope of improving filter condition. \r\n                        Instead of fetching all records where Qtr is either Q1 or Q2, it should just fetch records where Qtr is Q2 and use existing cached result for Qtr = Q1 from Step 3.\r\n                        So final query would be \"select Type, sum(Volume) from Stock where Qtr in ['Q2'] group by Type\"\r\n                        Once result is available, it will merge it with result from Step 3 and final result is produced for given filter condition.\r\n                        And at the end it will store query and result in cache.\r\n                        */\r\n                        mysmartfilter.smartfilterRequest({ type: \"filter\", data: { field: 'Qtr', filters: ['Q1', 'Q2'], filterType: 'in'} }, function (output) {\r\n                            if (output.type !== 'error') {\r\n                                /*\r\n                                Step 5. Apply Filter Qtr = 'Q2'\r\n                                Again here in traditional approach you will fire query like \"select Type, sum(Volume) from Stock where Qtr in ['Q2'] group by Type\"\r\n                                guess what, SmartFilter has already cached this query's and its output in Step 4.\r\n                                So result is returned directly from cache without even touching database.\r\n                                */\r\n                                mysmartfilter.smartfilterRequest({ type: \"filter\", data: { field: 'Qtr', filters: ['Q2'], filterType: 'in'} }, function (output) {\r\n                                    if (output.type !== 'error') {\r\n                                        console.log(\"Result:\", output.data, '\\n\\n');\r\n                                    }\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n});\r\n\r\n```\r\n",
  "readmeFilename": "README.md",
  "_id": "smartfilter@0.0.16",
  "_shasum": "3bc3287d0613a0f7cf5e5352b865737f2088e5cd",
  "_from": "smartfilter@*"
}
